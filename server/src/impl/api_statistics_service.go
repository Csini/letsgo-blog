/*
 * Let's go Blog API
 *
 * Application providing Blog.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"context"
	"errors"
	openapi "generated/openapi"
	//"net/http"

	log "github.com/sirupsen/logrus"

	"config"
	"entity"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	//"slices"
	//"fmt"
	"time"
)

// StatisticsAPIService is a service that implements the logic for the StatisticsAPIServicer
// This service should implement the business logic for every endpoint for the StatisticsAPI API.
// Include any external packages or services that will be required by this service.
type StatisticsAPIService struct {
}

// NewStatisticsAPIService creates a default api service
func NewStatisticsAPIService() openapi.StatisticsAPIServicer {
	return &StatisticsAPIService{}
}

// GetStatistics - Provides statistics about user activity
func (s *StatisticsAPIService) GetStatistics(ctx context.Context, days int32) (openapi.ImplResponse, error) {

	log.WithFields(log.Fields{
		"days": days,
	}).Info("Statistics called")

	db, err := gorm.Open(sqlite.Open(config.DB_NAME), &gorm.Config{

		PrepareStmt: true,
	})
	if err != nil {
		log.Error(err)
		return openapi.Response(500, nil), errors.New("GetStatistics failed to connect database")
	} else {
		log.Info("yuhuuuuu")
	}

	today := time.Now()

	//midnight
	beforeThisDate := time.Date(today.Year(), today.Month(), today.Day()-int(days), 0, 0, 0, 0, today.Location())

	log.WithFields(log.Fields{
		"beforeThisDate": beforeThisDate,
	}).Info("calculated")

	/*
		type CustomRawResult struct {
			username []rune
			amount   int32
		}
	*/
	//var blog_results []CustomRawResult
	var blog_results []map[string]interface{}
	// Where("updated_at > ?", lastWeek)
	db.Raw("select user_id as username, count(id) as amount from blogs WHERE created_at > ? group by user_id", beforeThisDate).Scan(&blog_results)

	log.Info(blog_results)

	var comment_results []map[string]interface{}
	//var comment_results []CustomRawResult
	db.Raw("select user_id as username, count(id) as amount from comments WHERE created_at > ? group by user_id", beforeThisDate).Scan(&comment_results)

	log.Info(comment_results)

	//TODO merge the two results with list of all users and send back as a list of Statistic

	var users []entity.User
	// Get all records
	db.Find(&users)
	// SELECT * FROM users;
	//result.RowsAffected // returns found records count, equals `len(users)`
	//result.Error        // returns error

	var statistics openapi.StatisticsResponse

	// using for loop
	for _, element := range users {

		log.Debug(element.Username)

		var amountBlog int32
		var amountComment int32

		for _, blog_result := range blog_results {
			log.Info(blog_result["username"])
			if blog_result["username"] == element.Username {
				log.Info(blog_result["amount"])
				//TODO
				//amountBlog = blog_result.amount
				break
			}
		}

		for _, comment_result := range comment_results {
			log.Info(comment_result["username"])
			if comment_result["username"] == element.Username {
				log.Info(comment_result["amount"])
				//TODO
				//amountComment = comment_result["amount"].(*int)
				break
			}
		}

		statistic := openapi.Statistic{Userid: element.Username, AmountBlog: amountBlog, AmountComment: amountComment}

		statistics.Items = append(statistics.Items,
			statistic)
	}

	//TODO
	//statistics.Size = len(statistics.Items)

	return openapi.Response(200, statistics), nil

}