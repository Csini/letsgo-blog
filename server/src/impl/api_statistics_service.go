/*
 * Let's go Blog API
 *
 * Application providing Blog.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"context"
	"errors"
	openapi "generated/openapi"
	//"net/http"

	log "github.com/sirupsen/logrus"

	"config"
	"entity"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	//"slices"
	//"fmt"
	"time"
)

// StatisticsAPIService is a service that implements the logic for the StatisticsAPIServicer
// This service should implement the business logic for every endpoint for the StatisticsAPI API.
// Include any external packages or services that will be required by this service.
type StatisticsAPIService struct {
}

// NewStatisticsAPIService creates a default api service
func NewStatisticsAPIService() openapi.StatisticsAPIServicer {
	return &StatisticsAPIService{}
}

// GetStatistics - Provides statistics about user activity
func (s *StatisticsAPIService) GetStatistics(ctx context.Context, days int32) (openapi.ImplResponse, error) {

	log.WithFields(log.Fields{
		"days": days,
	}).Info("Statistics called")

	db, err := gorm.Open(sqlite.Open(config.GetDbName()), &gorm.Config{

		PrepareStmt: true,
	})
	if err != nil {
		log.Error(err)
		return openapi.Response(500, nil), errors.New("GetStatistics failed to connect database")
	} else {
		log.Info("yuhuuuuu")
		//sqlite
		db.Exec("PRAGMA foreign_keys = ON")
	}

	today := time.Now()

	//midnight
	beforeThisDate := time.Date(today.Year(), today.Month(), today.Day()-int(days), 0, 0, 0, 0, today.Location())

	log.WithFields(log.Fields{
		"beforeThisDate": beforeThisDate,
	}).Info("calculated")

	var statistics openapi.StatisticsResponse

	statistics.BeforeThisDate = beforeThisDate

	type CustomRawResult struct {
		username string
		amount   int32
	}

	var blog_results []CustomRawResult
	//var blog_results []map[string]interface{}
	// Where("updated_at > ?", lastWeek)
	//db.Raw("select user_id as username, count(id) as amount from blogs WHERE created_at > ? group by user_id", beforeThisDate).Scan(&blog_results)
	//db.Table("blogs").Select("user_id as username, count(id) as amount").Where("created_at > ?", beforeThisDate).Group("user_id").Find(&blog_results)

	var comment_results []CustomRawResult
	//var comment_results []map[string]interface{}
	//db.Raw("select user_id as username, count(id) as amount from comments WHERE created_at > ? group by user_id", beforeThisDate).Scan(&comment_results)

	// Raw SQL
	blog_rows, err := db.Raw("select user_id as username, count(id) as amount from blogs WHERE created_at > ? group by user_id", beforeThisDate).Rows()
	defer blog_rows.Close()
	for blog_rows.Next() {
		var username string
		var amount int32
		blog_rows.Scan(&username, &amount)

		blog_row := CustomRawResult{username: username, amount: amount}
		blog_results = append(blog_results,
			blog_row)
	}
	log.Debug(blog_results)

	comment_rows, err := db.Raw("select user_id as username, count(id) as amount from comments WHERE created_at > ? group by user_id", beforeThisDate).Rows()
	defer comment_rows.Close()
	for comment_rows.Next() {
		var username string
		var amount int32
		comment_rows.Scan(&username, &amount)

		comment_row := CustomRawResult{username: username, amount: amount}
		comment_results = append(blog_results,
			comment_row)
	}
	log.Debug(comment_results)

	//merge the two results with list of all users and send back as a list of Statistic

	var users []entity.User
	// Get all records
	db.Find(&users)
	// SELECT * FROM users;
	//result.RowsAffected // returns found records count, equals `len(users)`
	//result.Error        // returns error

	// using for loop
	for _, element := range users {

		//log.Debug(element.Username)

		var amountBlog int32
		var amountComment int32

		for _, blog_result := range blog_results {
			if blog_result.username == element.Username {
				log.WithFields(log.Fields{
					"blog_result.amount":   blog_result.amount,
					"blog_result.username": blog_result.username,
				}).Info(element.Username)
				amountBlog = blog_result.amount
				break
			}
		}

		for _, comment_result := range comment_results {
			if comment_result.username == element.Username {
				log.WithFields(log.Fields{
					"comment_result.amount":   comment_result.amount,
					"comment_result.username": comment_result.username,
				}).Info(element.Username)
				amountComment = comment_result.amount
				break
			}
		}

		amountObject := openapi.Amount{Blog: amountBlog, Comment: amountComment}
		statistic := openapi.Statistic{Userid: element.Username, Amount: amountObject}

		statistics.Items = append(statistics.Items,
			statistic)
	}

	statistics.Size = int32(len(statistics.Items))

	return openapi.Response(200, statistics), nil

}
