/*
 * Let's go Blog API
 *
 * Application providing Blog.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"context"
	"errors"
	//"net/http"

	log "github.com/sirupsen/logrus"

	"entity"
	openapi "generated/openapi"

	utils_jwt "utils/jwt"

	"gorm.io/gorm"
	utils_db "utils/db"

	"golang.org/x/crypto/bcrypt"
	//"time"
)

// AuthenticationAPIService is a service that implements the logic for the AuthenticationAPIServicer
// This service should implement the business logic for every endpoint for the AuthenticationAPI API.
// Include any external packages or services that will be required by this service.
type AuthenticationAPIService struct {
}

// NewAuthenticationAPIService creates a default api service
func NewAuthenticationAPIService() openapi.AuthenticationAPIServicer {
	return &AuthenticationAPIService{}
}

// PostLogin - provides JWT token
func (s *AuthenticationAPIService) PostLogin(ctx context.Context, loginRequest openapi.LoginRequest) (openapi.ImplResponse, error) {

	var gormconfig = &gorm.Config{

		PrepareStmt: false,
	}

	db, err := utils_db.OpenConnection(gormconfig)

	if err != nil {
		return openapi.Response(500, nil), err
	}

	var user entity.User
	// Get
	result := db.Table("users").Select("username, pw").Where("username=?", loginRequest.User).Scan(&user)
	//result.RowsAffected // returns found records count, equals `len(users)`
	//result.Error        // returns error
	if result.Error != nil {
		return openapi.Response(401, nil), errors.New("PostLogin - bad User or pw")
	}

	if checkPasswordHash(loginRequest.Pw, user.Pw) {

		token, err := utils_jwt.GenerateJWT(user.Username)

		if err != nil {
			log.Error(err)
			return openapi.Response(401, nil), errors.New("PostLogin - Token generation error")
		}

		return openapi.Response(200, token), nil
	}

	return openapi.Response(401, nil), errors.New("PostLogin - bad User or pw")
}

func hashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

func checkPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}
